#summary kvs::ValueArray
#sidebar programming_guide_toc_jp

= kvs::!ValueArrayクラス =

||ヘッダファイル||`#include <kvs/ValueArray>`||
||クラス名||`kvs::ValueArray<T>`||

== 機能 ==
このクラスは、数値型の配列を表すクラスです。通常の配列と同じ働きをしますが、配列のサイズ（要素数）の管理に加えて、データの共有を実現することができます。配列のコピーという操作には、見かけ上複数の配列が生成されますが、実際には同じデータであるので、メモリ上でそのデータを共有するコピー（shallow copy）と、実際にメモリ上で同じデータを複数配置するコピー（deep copy）が考えられます。kvs::!ValueArrayクラスを利用して、このような操作を簡単に実現することができます。

== 主なメソッド ==
このクラスの主なメソッドを説明します。他のメソッドの機能はだいたいSTLコンテナと同じです。

{{{
ValueArray( const size_t size )
}}}
size個の要素を持つ配列を新たに確保します。<br>
事後条件:size() == size

{{{
ValueArray( const T* values, const size_t size )
}}}
`size`個の要素を持つ配列を新たに確保し、`values`が指す要素を先頭として、`size`個の要素で配列を初期化します。<br>
事前条件:`[ values, values+size )`が有効な範囲である。<br>
事後条件:`size() == size`<br>

{{{
ValueArray( const std::vector<T>& values )
}}}
事後条件:`size() == values.size()`<br>

{{{
template <typename InIter>
ValueArray( InIter first, InIter last )
}}}
事前条件:`[ first, last )`が有効な範囲である。<br>
事後条件:`size() == std::distance( first, last )`<br>

{{{
void assign( const value_type* values, const size_t size )
}}}
要素を代入します。<br>
`v.assign( values, size )`
は
`v = ValueArray( values, size )`
と等価です。

{{{
template <typename InIter>
void assign( InIter first, InIter last )
}}}
要素を代入します。<br>
`v.assign( first, last )`
は
`v = ValueArray( first, last )`
と等価です。

{{{
T& operator []( const size_t index )
const T& operator []( const size_t index ) const
}}}
`index`番目の要素にアクセスします。<br>
事前条件:`index < size()`

{{{
size_t size() const
}}}
配列の要素数を返します。

{{{
size_t byteSize() const
}}}
配列のメモリ上での大きさをバイト単位で返します。

{{{
void swap( ValueArray& other )
}}}
`other`と配列を入れ替えます。

{{{
ValueArray clone() const
}}}
配列のdeep copyを返します。

{{{
T& at( const size_t index )
const T& at( const size_t index ) const
}}}
事前条件:`index < size()`

{{{
void allocate( const size_t size )
}}}
`size`個の要素を新たに確保します。<br>
事後条件:`size() == size`

{{{
void release()
}}}
配列を解放します。<br>
事後条件:`empty() == true`

{{{
void fill( const T& value )
}}}
配列の要素を全て`value`で埋めます。

{{{
bool unique() const
}}}
配列が共有されていなければ`true`を返します。<br>
ただし、`empty() == true`の場合の返り値は不定です。
<wiki:comment>
これはSharedPointer(std::shared_ptr)の仕様です。
</wiki:comment>

{{{
void isolate()
}}}
配列の共有を切断します。<br>
配列を共有している他の`ValueArray`に影響を与えずに配列の内容を書き換えたい場合に使用します。<br>
事後条件:`unique() == true || empty() == true`<br>
<wiki:comment>
unique() == trueの方がわかりやすくていいか？
</wiki:comment>

== サンプルプログラム ==