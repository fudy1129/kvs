= KVS 1.x から 2.x への移行ガイド =

KVS 1.x から2.0へのバージョンアップに伴い、いくつかの仕様の変更とAPIの変更があります。ここでは、移行の際のガイドラインとして、変更があった仕様およびクラスについて、その修正方法とともにまとめています。

<wiki:toc max_depth="3"/>

----

== バージョンの確認 ==
現在、利用しているKVSのバージョンを確認する方法について説明します。

=== kvscheckコマンドを利用した確認方法 ===
kvscheckコマンドを利用して、現在インストールされているKVSのバージョンを確認することができます。コマンドターミナルを開けて、以下のようにコマンドを実行してください。kvscheckコマンドの利用法については[KVS_kvscheck_jp こちら]を参考にしてください。

{{{
> kvsmake -version
KVS version: 2.0.0
}}}

=== ソースコード内での確認方法 ===
kvs::Versionクラスを利用して、ソースコード内でKVSのバージョンを確認することができます。ヘッダファイル「`<kvs/Version>`」をインクルードし、以下のようにしてバージョン情報を取得することができます。[KVS_programming_build_jp こちら]にも説明がありますので、参考にしてください。

{{{
#include <kvs/Version>
}}}
{{{
size_t major = kvs::Version::MajorVersion(); // メジャーバージョン番号の取得
size_t minor = kvs::Version::MinorVersion(); // マイナーバージョン番号の取得
size_t patch = kvs::Version::PatchVersion(); // パッチバージョン番号の取得
}}}

=== プリプロセッサ命令を利用した確認方法 ===
プリプロセッサ命令（#if）を利用して、コンパイル時にバージョンを確認することができます。ヘッダファイル「`<kvs/Version>`」をインクルードし、以下のようにしてバージョンの違いによりソースコードの記述を切り分けることができます。

{{{
#include <kvs/Version>
}}}
{{{
#if ( KVS_VERSION_MAJOR == 1 )
    // KVSのバージョンが1.x.xのときの処理
#elif ( KVS_VERSION_MAJOR == 2 )
    // KVSのバージョンが2.x.xのときの処理
#endif
}}}

== 削除されたクラス ==

=== kvs::glut::!GlobalBase, kvs::glut::!ScreenBaseなど ===
KVS1.0をリリースする以前のバージョンでは、たとえば、GLUTを使ってビューワアプリケーションを作成する場合は、ユーザが`kvs::glut::GlobalBase`および`kvs::glut::ScreenBase`を継承して独自のグローバルクラスおよびスクリーンクラスを定義する必要がありました。KVS1.0では、`kvs::glut::Application`および`kvs::glut::Screen`を利用して、継承することなく、ビューワアプリケーションの開発が可能となりましたが、下位バージョンとの互換性のために、それらに関連するクラスを残していました。KVS2.0へのバージョンアップを機に、下位互換性のために残していた以下のクラスを削除しました。

{{{
// 削除されたクラス
kvs::GlobalCore
kvs::ScreenCore
kvs::WindowBase
kvs::glut::GlobalBase
kvs::glut::ScreenBase
kvs::glut::Window
kvs::qt::GlobalBase
kvs::qt::ScreenBase
kvs::qt::Window
kvs::sage::GlobalBase
kvs::sage::ScreenBase
}}}

KVS2.0以降のバージョンでは、以下のクラスを利用してください。ビューワアプリケーションの開発は、[KVS_programming_draw_jp こちら]を参考にしてください。

{{{
kvs::glut::Application
kvs::glut::Screen
kvs::qt::Application
kvs::qt::Screen
kvs::sage::Application
kvs::sage::Screen
}}}

== ファイルフォーマットクラス ==

=== kvs::AVSFieldなど ===
kvs::AVSFieldクラスなど!FileFormatに所属するクラスは、読み込んだデータの情報を標準出力するために<<オペレータを定義していましたが、それを廃止しインデント付き出力にも対応するためにprintメソッドを追加しました。その他、staticメソッド名の変更および一部廃止しました。

==== 修正点1 ====
<<オペレータの代わりにprintメソッドを利用してください。
{{{
// 修正前
kvs::AVSField field("lobster.fld");
std::cout << field << std::endl;
}}}
{{{
// 修正後
kvs::AVSField field("lobster.fld");
field.print( std::cout ); // インデントなし
field.print( std::cout, kvs::Indent(2) ); // インデント２を指定
}}}

==== 修正点2 ====
メソッド名を以下のように修正してください。ただし、KVSML関係クラス以外のクラスにおいては、!CheckFileFormatメソッドを廃止しました。
{{{
// 修正前
CheckFileExtension
CheckFileFormat
}}}
{{{
// 修正後
CheckExtension
CheckFormat // KVSML関係クラスのみ
}}}

== 行列演算クラス ==

=== kvs::Vector2, kvs::Vector3, kvs::Vector4, kvs::Vector ===
ベクトル系クラスでは、正規化されたベクトルを返すメソッドnormalizeが実装されていたが、自分自身が正規化される場合とされない場合の２つのメソッドが同じ名前で実装されていました。KVS2.0では、混乱を避けるために、自分自身を正規化するメソッド（正規化されたベクトルは返さない）と、正規化されたベクトルを返すメソッド（自分自身は正規化されない）を、それぞれ、normalizeとnormalizedとして処理を区別するようにしました。その他、いくつかの初期化メソッドを廃止しました。

==== 修正点1 ====
以下に修正例を示します。
{{{
// 修正前
kvs::Vector3f v1( 1, 2, 3 );
kvs::Vecto3f v2 = v1.normalize(); // v1の正規化ベクトルをv2にコピー（v1は正規化される？されない？）
v1.normalize(); // v1を正規化（v1は正規化される？されない？）
}}}
{{{
// 修正後
kvs::Vector3f v1( 1, 2, 3 );
kvs::Vecto3f v2 = v1.normalized(); // v1の正規化ベクトルをv2にコピー（v1は正規化されない）
v1.normalize(); // v1を正規化（v1は正規化される）
}}}

==== 修正点2 ====
全ての要素を指定した値で初期化するためのコンストラクタとsetメソッドを廃止しました。代わりにAllメソッドを使用してください。
{{{
// 修正前
kvs::Vector3f v( 2.0 ); // 全ての要素を2.0にする。
v.set( 3.0 ); // 全ての要素を3.0にする。
}}}
{{{
// 修正前
kvs::Vector3f v = kvs::Vector3f::All( 2.0 ); // 全ての要素を2.0にする。
v = kvs::Vector3f::All( 3.0 ); // 全ての要素を3.0にする。
}}}

=== kvs::Matrix22, kvs::Matrix33, kvs::Matrix44, kvs::Matrix ===
マトリックス系クラスにおいても、ベクトル系クラスと同様に、逆行列を計算するメソッドinverseと転置行列を計算するメソッドtransposeが、それぞれ2つの同名メソッド（自分自身を書き換えるものと書き換えないもの）があるために混乱が生じていました。KVS2.0では、自分自身を書き換えるメソッドinverse, transposeと、自分自身を書き換えず処理された行列を返すメソッドinversed, transposedとして処理を区別するようにしました。その他、いくつかの初期化メソッドを廃止しました。

==== 修正点1 ====
以下に修正例を示します。
{{{
// 修正前
kvs::Matrix33f m1( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
kvs::Matrix33f m2 = m1.inverse(); // m1の逆行列をm2にコピー（m1は逆行列になる？ならない？）
kvs::Matrix33f m3 = m2.transpose(); // m2の転置行列をm3にコピー（m2は転置行列になる？ならない？）
m1.inverse(); // m1の逆行列を計算（m1は逆行列になる？ならない？）
m2.transpose(); // m2の転置行列を計算（m2は転置行列になる？ならない？）
}}}
{{{
// 修正後
kvs::Matrix33f m1( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
kvs::Matrix33f m2 = m1.inversed(); // m1の逆行列をm2にコピー（m1は逆行列ならない）
kvs::Matrix33f m3 = m2.transposed(); // m2の転置行列をm3にコピー（m2は転置行列ならない）
m1.inverse(); // m1の逆行列を計算（m1は逆行列になる）
m2.transpose(); // m2の転置行列を計算（m2は転置行列になる）
}}}

==== 修正点2 ====
全ての要素を指定した値で初期化するためのコンストラクタとsetメソッドを廃止しました。代わりにAllメソッドを使用してください。
{{{
// 修正前
kvs::Matrix33f m( 2.0 ); // 全ての要素を2.0にする。
m.set( 3.0 ); // 全ての要素を3.0にする。
}}}
{{{
// 修正前
kvs::Matrix33f m = kvs::Matrix33f::All( 2.0 ); // 全ての要素を2.0にする。
m = kvs::Matrix33f::All( 3.0 ); // 全ての要素を3.0にする。
}}}

=== kvs::Matrix ===
行列の行数と列数を取得するためのメソッドの名前を変更しました。

==== 修正点 ====
以下のように修正してください。
{{{
// 修正前
kvs::Matrix<float> m( 3, 4 );
size_t nrows = m.nrows(); // 行数を取得する。
size_t ncolumns = m.ncolumns(); // 列数を取得する。
}}}
{{{
// 修正後
kvs::Matrix<float> m( 3, 4 );
size_t nrows = m.rowSize(); // 行数を取得する。
size_t ncolumns = m.columnSize(); // 列数を取得する。
}}}

== 数値計算クラス ==

=== kvs::!ResponseSurface ===
サンプル点の数および変数の数を取得するメソッド名を変更しました。

==== 修正点1 ====
メソッド名を以下のように修正しました。
{{{
// 修正前
kvs::ResponseSurface rs;
size_t npoints = rs.npoints(); // サンプル点の数の取得
size_t nvariables = rs.nvariables(); // 変数の数の取得
}}}
{{{
// 修正後
kvs::ResponseSurface rs;
size_t npoints = rs.numberOfPoints(); // サンプル点の数の取得
size_t nvariables = rs.numberOfVariables(); // 変数の数の取得
}}}

== スレッドクラス ==

=== kvs::Thread ===
３つのスリープメソッドの名前を変更しました。

==== 修正点1 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
kvs::Thread::sleep(1); // 1秒スリープ
kvs::Thread::msleep(1); // 1ミリ秒スリープ
kvs::Thread::usleep(1); // 1マイクロ秒スリープ
}}}
{{{
// 修正後
kvs::Thread::Sleep(1); // 1秒スリープ
kvs::Thread::MilliSleep(1); // 1ミリ秒スリープ
kvs::Thread::MicroSleep(1); // 1マイクロ秒スリープ
}}}

== 可視化クラス ==

=== kvs::Tubeline ===
チューブの分割数を指定するメソッドの名前を修正しました。

==== 修正点1 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
kvs::Tubeline* tubeline = new kvs::Tubeline();
tubeline->setNDivisions( 10 );
}}}
{{{
// 修正後
kvs::Tubeline* tubeline = new kvs::Tubeline();
tubeline->setNumberOfDivisions( 10 );
}}}

== ユーティリティクラス ==

=== kvs::!CommandLine ===
KVS 1.xでは、add_help_option, add_option, add_valueメソッドがprotected属性であったために、ユーザプログラム内で、kvs::!CommandLineクラスを継承し、独自のコマンド引数処理クラスを定義する必要がありました。KVS 2.0では、これらのメソッドをpublic属性として定義することで、継承することなくコマンドライン引数の処理を行うことが可能となります。その他、いくつかのメソッド名の変更があります。

==== 修正点 ====
メソッド名を以下のように修正してください。kvs::!CommandLineクラスを継承せずに利用する方法については、[guide_commandline_jp こちら]を参考にしてください。
{{{
// 修正前
add_help_option
add_option
add_value

noptions
nvalues
}}}
{{{
// 修正後
addHelpOption
addOption
addValue

numberOfOptions
numberOfValues
}}}

=== kvs::Directory ===
「ディレクトリが存在するかどうか」を確認するためのメソッド名を変更しました。

==== 修正点 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
isExisted
}}}
{{{
// 修正後
exists
}}}

=== kvs::File ===
「ファイルが存在するかどうか」を確認するためのメソッド名を変更しました。

==== 修正点 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
isExisted
}}}
{{{
// 修正後
exists
}}}

=== kvs::Endian ===
いくつかのメソッド名および引数の仕様を変更しました。

==== 修正点1 ====
Checkが何を確認するのかが不明瞭であったため、Checkを廃止し、具体的にビッグエンディアンまたはリトルエンディアンかどうかを確認するためのメソッド（!IsBig, !IsLittle）を追加しましたので、以下のように修正してください。

{{{
// 修正前
if ( kvs::Endian::Check() == kvs::Endian::Big )
    // ビッグエンディアンであった場合の処理
if ( kvs::Endian::Check() == kvs::Endian::Little )
    // リトルエンディアンであった場合の処理
}}}

{{{
// 修正後
if ( kvs::Endian::IsBig() )
    // ビッグエンディアンであった場合の処理
if ( kvs::Endian::IsLittle() )
    // リトルエンディアンであった場合の処理
}}}

==== 修正点2 ====
プログラミング規約に従いバイトスワップ対象となる数値を参照渡しではなくポインタ渡しに変更しましたので、以下のように修正してください。

{{{
// 修正前
kvs::Real32 value = 123.4f;
kvs::Endian::Swap( value );
}}}

{{{
// 修正後
kvs::Real32 value = 123.4f;
kvs::Endian::Swap( &value );
}}}


=== kvs::!ValueArray ===

==== 修正点1 ====
`shallowCopy( const ValueArray& )`が廃止されました。代わりに代入演算子を使用してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = b;
}}}

==== 修正点2 ====
`deepCopy( const ValueArray& )`が廃止されました。代わりに`clone()`を使用してください。

{{{
// 修正前
a.deepCopy( b );
}}}

{{{
// 修正後
a = b.clone();
}}}

==== 修正点3 ====
`deepCopy( const T*, size_t )`が廃止されました。代わりに`assign()`を使用してください。

{{{
// 修正前
a.deepCopy( b, n );
}}}

{{{
// 修正後
a.assign( b, n );
}}}

==== 修正点4 ====
`isEmpty()`の名称が`empty()`に変更されました。

{{{
// 修正前
a.isEmpty();
}}}

{{{
// 修正後
a.empty();
}}}

==== 修正点5 ====
`swapByte()`が廃止されました。代わりに`Endian::Swap()`を使用してください。ただし数値型に限ります。

{{{
// 修正前
a.swapByte();
}}}

{{{
// 修正後
kvs::Endian::Swap( a.data(), a.size() );
}}}

==== 修正点6 ====
`deallocate()`の名称が`release()`に変更されました。

{{{
// 修正前
a.deallocate();
}}}

{{{
// 修正後
a.release();
}}}

==== 修正点7 ====
`allocate( size_t )`の返り値が`void`に変更されました。従来の返り値を使用したい場合は、`data()`を使用してください。なお、従来はメモリ確保に失敗した場合、`NULL`を返す場合がありましたが、KVS2.0では、`std::bad_alloc`が投げられます。

{{{
// 修正前
T* p = a.allocate( n );
}}}

{{{
// 修正後
a.allocate( n );
T* p = a.data();
}}}

==== 修正点8 ====
`pointer()`の名称が`data()`に変更されました。

{{{
// 修正前
a.pointer();
}}}

{{{
// 修正後
a.data();
}}}

==== 修正点9 ====
`counter()`が廃止されました。完全な代替の関数はありませんが、`counter()->value()`と同等の値は`use_count()`で取得できます。また、手動で参照カウントを増加、減少させる`counter()->increment(`)及び`counter()->decrement()`は、`sharedPointer()`で共有ポインタを取得し、それを別の場所で保持することで代替可能です。マルチスレッド時に、`counter()->key()`によって実現していたMutexによる排他処理は、`KVS_ENABLE_THREAD_SAFE`をコンパイル時にセットすることで自動で行われるようになりました。

=== kvs::!AnyValueArray ===
以前の`AnyValueArray`の使い方は危険なものが多かったので、直接配列の中身を操作するような関数を廃止し、`ValueArray`をラップすることに集中し、配列の操作は`ValueArray`に任せる形にしました。直接配列の中身を操作したい場合は、`asValueArray`で`ValueArray`型に変換してから使ってください。なお、`v = a.asValueArray<T>()`のようにして生成した`ValueArray v`は、`a`と配列を共有します。このため、`v`を書き換えると、`a`の内容も書き換わります。このことに注意して使ってください。

==== 修正点1 ====
コンストラクタ`AnyValueArray( const T*, size_t )`が廃止されました。以下のように修正してください。

{{{
// 修正前
AnyValueArray a( p, n );
}}}

{{{
// 修正後
AnyValueArray a( kvs::ValueArray( p, n ) );
}}}

==== 修正点2 ====
コンストラクタ`AnyValueArray( const std::vector<T>& )`が廃止されました。以下のように修正してください。

{{{
// 修正前
kvs::AnyValueArray a( v );
}}}

{{{
// 修正後
kvs::AnyValueArray a( kvs::ValueArray( v ) );
}}}

==== 修正点3 ====
`shallowCopy( const ValueArray<T>& )`が廃止されました。以下のように修正してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = kvs::AnyValueArray( b );
}}}

==== 修正点4 ====
`shallowCopy( const AnyValueArray& )`が廃止されました。代わりに代入演算子を使用してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = b;
}}}

==== 修正点5 ====
`deepCopy( const T*, size_t )`が廃止されました。以下のように修正してください。

{{{
// 修正前
a.deepCopy( p, n );
}}}

{{{
// 修正後
a = kvs::AnyValueArray( kvs::ValueArray( p, n ) );
}}}

==== 修正点6 ====
`isEmpty()`の名称が`empty()`に変更されました。

{{{
// 修正前
a.isEmpty();
}}}

{{{
// 修正後
a.empty();
}}}

==== 修正点7 ====
`swapByte()`が廃止されました。代わりに`Endian::Swap()`を使用してください。以下のように修正すれば、同等の機能が得られますが、基本的にエンディアン変換は`ValueArray`の段階で行なってください。

{{{
// 修正前
a.swapByte();
}}}

{{{
// 修正後

}}}

==== 修正点8 ====
`deallocate()`の名称が`release()`に変更されました。

{{{
// 修正前
a.deallocate();
}}}

{{{
// 修正後
a.release();
}}}

==== 修正点9 ====
`pointer()`の名称が`data()`に変更されました。

{{{
// 修正前
a.pointer();
}}}

{{{
// 修正後
a.data();
}}}

==== 修正点10 ====
`pointer<T>()`が廃止されました。以下のようにすれば、同等の機能が得られますが、基本的に`ValueArray`に変換してから`ValueArray.data()`を使うようにしてください。

{{{
// 修正前
a.pointer<T>();
}}}

{{{
// 修正後
static_cast<T*>( a.data() ); //非const版
static_cast<const T*>( a.data() ); //const版
}}}

==== 修正点11 ====
`counter()`が廃止されました。代替の関数はありませんが、`sharedPointer()`を使うことで、同等の機能を得ることができます。詳しくは`ValueArray.counter()`の修正を参照してください。