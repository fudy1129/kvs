= KVS 1.x から 2.x への移行ガイド =

KVS 1.x から2.0へのバージョンアップに伴い、いくつかの仕様の変更とAPIの変更があります。ここでは、移行の際のガイドラインとして、変更があった仕様およびクラスについて、その修正方法とともにまとめています。

<wiki:toc max_depth="3"/>

----

== バージョンの確認 ==
現在、利用しているKVSのバージョンを確認する方法について説明します。

=== kvscheckコマンドを利用した確認方法 ===
kvscheckコマンドを利用して、現在インストールされているKVSのバージョンを確認することができます。コマンドターミナルを開けて、以下のようにコマンドを実行してください。kvscheckコマンドの利用法については[KVS_kvscheck_jp こちら]を参考にしてください。

{{{
> kvsmake -version
KVS version: 2.0.0
}}}

=== ソースコード内での確認方法 ===
kvs::Versionクラスを利用して、ソースコード内でKVSのバージョンを確認することができます。ヘッダファイル「`<kvs/Version>`」をインクルードし、以下のようにしてバージョン情報を取得することができます。[KVS_programming_build_jp こちら]にも説明がありますので、参考にしてください。

{{{
#include <kvs/Version>
}}}
{{{
size_t major = kvs::Version::MajorVersion(); // メジャーバージョン番号の取得
size_t minor = kvs::Version::MinorVersion(); // マイナーバージョン番号の取得
size_t patch = kvs::Version::PatchVersion(); // パッチバージョン番号の取得
}}}

=== プリプロセッサ命令を利用した確認方法 ===
プリプロセッサ命令（#if）を利用して、コンパイル時にバージョンを確認することができます。ヘッダファイル「`<kvs/Version>`」をインクルードし、以下のようにしてバージョンの違いによりソースコードの記述を切り分けることができます。

{{{
#include <kvs/Version>
}}}
{{{
#if ( KVS_VERSION_MAJOR == 1 )
    // KVSのバージョンが1.x.xのときの処理
#elif ( KVS_VERSION_MAJOR == 2 )
    // KVSのバージョンが2.x.xのときの処理
#endif
}}}

== 削除されたクラス ==

=== kvs::glut::!GlobalBase, kvs::glut::!ScreenBaseなど ===
KVS1.0をリリースする以前のバージョンでは、たとえば、GLUTを使ってビューワアプリケーションを作成する場合は、ユーザが`kvs::glut::GlobalBase`および`kvs::glut::ScreenBase`を継承して独自のグローバルクラスおよびスクリーンクラスを定義する必要がありました。KVS1.0では、`kvs::glut::Application`および`kvs::glut::Screen`を利用して、継承することなく、ビューワアプリケーションの開発が可能となりましたが、下位バージョンとの互換性のために、それらに関連するクラスを残していました。KVS2.0へのバージョンアップを機に、下位互換性のために残していた以下のクラスを削除しました。

{{{
// 削除されたクラス
kvs::GlobalCore
kvs::ScreenCore
kvs::WindowBase
kvs::glut::GlobalBase
kvs::glut::ScreenBase
kvs::glut::Window
kvs::qt::GlobalBase
kvs::qt::ScreenBase
kvs::qt::Window
kvs::sage::GlobalBase
kvs::sage::ScreenBase
}}}

KVS2.0以降のバージョンでは、以下のクラスを利用してください。ビューワアプリケーションの開発は、[KVS_programming_draw_jp こちら]を参考にしてください。

{{{
kvs::glut::Application
kvs::glut::Screen
kvs::qt::Application
kvs::qt::Screen
kvs::sage::Application
kvs::sage::Screen
}}}

== ファイルフォーマットクラス ==

=== kvs::AVSFieldなど ===
kvs::AVSFieldクラスなど!FileFormatに所属するクラスは、読み込んだデータの情報を標準出力するために<<オペレータを定義していましたが、それを廃止しインデント付き出力にも対応するためにprintメソッドを追加しました。その他、staticメソッド名の変更および一部廃止しました。

==== 修正点1 ====
<<オペレータの代わりにprintメソッドを利用してください。
{{{
// 修正前
kvs::AVSField field("lobster.fld");
std::cout << field << std::endl;

// 修正後
kvs::AVSField field("lobster.fld");
field.print( std::cout ); // インデントなし
field.print( std::cout, kvs::Indent(2) ); // インデント２を指定
}}}

==== 修正点2 ====
メソッド名を以下のように修正してください。ただし、KVSML関係クラス以外のクラスにおいては、!CheckFileFormatメソッドを廃止しました。
{{{
// 修正前
CheckFileExtension
CheckFileFormat

// 修正後
CheckExtension
CheckFormat // KVSML関係クラスのみ
}}}

== ユーティリティクラス ==

=== kvs::!CommandLine ===
KVS 1.xでは、add_help_option, add_option, add_valueメソッドがprotected属性であったために、ユーザプログラム内で、kvs::!CommandLineクラスを継承し、独自のコマンド引数処理クラスを定義する必要がありました。KVS 2.0では、これらのメソッドをpublic属性として定義することで、継承することなくコマンドライン引数の処理を行うことが可能となります。その他、いくつかのメソッド名の変更があります。

==== 修正点 ====
メソッド名を以下のように修正してください。kvs::!CommandLineクラスを継承せずに利用する方法については、[guide_commandline_jp こちら]を参考にしてください。
{{{
// 修正前
add_help_option
add_option
add_value

noptions
nvalues
}}}
{{{
// 修正後
addHelpOption
addOption
addValue

numberOfOptions
numberOfValues
}}}

=== kvs::Directory ===
「ディレクトリが存在するかどうか」を確認するためのメソッド名を変更しました。

==== 修正点 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
isExisted
}}}
{{{
// 修正後
exists
}}}

=== kvs::File ===
「ファイルが存在するかどうか」を確認するためのメソッド名を変更しました。

==== 修正点 ====
メソッド名を以下のように修正してください。
{{{
// 修正前
isExisted
}}}
{{{
// 修正後
exists
}}}

=== kvs::Endian ===
いくつかのメソッド名および引数の仕様を変更しました。

==== 修正点1 ====
Checkが何を確認するのかが不明瞭であったため、Checkを廃止し、具体的にビッグエンディアンまたはリトルエンディアンかどうかを確認するためのメソッド（!IsBig, !IsLittle）を追加しましたので、以下のように修正してください。

{{{
// 修正前
if ( kvs::Endian::Check() == kvs::Endian::Big )
    // ビッグエンディアンであった場合の処理
if ( kvs::Endian::Check() == kvs::Endian::Little )
    // リトルエンディアンであった場合の処理
}}}

{{{
// 修正後
if ( kvs::Endian::IsBig() )
    // ビッグエンディアンであった場合の処理
if ( kvs::Endian::IsLittle() )
    // リトルエンディアンであった場合の処理
}}}

==== 修正点2 ====
プログラミング規約に従いバイトスワップ対象となる数値を参照渡しではなくポインタ渡しに変更しましたので、以下のように修正してください。

{{{
// 修正前
kvs::Real32 value = 123.4f;
kvs::Endian::Swap( value );
}}}

{{{
// 修正後
kvs::Real32 value = 123.4f;
kvs::Endian::Swap( &value );
}}}


=== kvs::!ValueArray ===

==== 修正点1 ====
`shallowCopy( const ValueArray& )`が廃止されました。代わりに代入演算子を使用してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = b;
}}}

==== 修正点2 ====
`deepCopy( const ValueArray& )`が廃止されました。代わりに`clone()`を使用してください。

{{{
// 修正前
a.deepCopy( b );
}}}

{{{
// 修正後
a = b.clone();
}}}

==== 修正点3 ====
`deepCopy( const T*, size_t )`が廃止されました。代わりに`assign()`を使用してください。

{{{
// 修正前
a.deepCopy( b, n );
}}}

{{{
// 修正後
a.assign( b, n );
}}}

==== 修正点4 ====
`isEmpty()`の名称が`empty()`に変更されました。

{{{
// 修正前
a.isEmpty();
}}}

{{{
// 修正後
a.empty();
}}}

==== 修正点5 ====
`swapByte()`が廃止されました。代わりに`Endian::Swap()`を使用してください。ただし数値型に限ります。

{{{
// 修正前
a.swapByte();
}}}

{{{
// 修正後
kvs::Endian::Swap( a.data(), a.size() );
}}}

==== 修正点6 ====
`deallocate()`の名称が`release()`に変更されました。

{{{
// 修正前
a.deallocate();
}}}

{{{
// 修正後
a.release();
}}}

==== 修正点7 ====
`allocate( size_t )`の返り値が`void`に変更されました。従来の返り値を使用したい場合は、`data()`を使用してください。なお、従来はメモリ確保に失敗した場合、`NULL`を返す場合がありましたが、KVS2.0では、`std::bad_alloc`が投げられます。

{{{
// 修正前
T* p = a.allocate( n );
}}}

{{{
// 修正後
a.allocate( n );
T* p = a.data();
}}}

==== 修正点8 ====
`pointer()`の名称が`data()`に変更されました。

{{{
// 修正前
a.pointer();
}}}

{{{
// 修正後
a.data();
}}}

==== 修正点9 ====
`counter()`が廃止されました。完全な代替の関数はありませんが、`counter()->value()`と同等の値は`use_count()`で取得できます。また、手動で参照カウントを増加、減少させる`counter()->increment(`)及び`counter()->decrement()`は、`sharedPointer()`で共有ポインタを取得し、それを別の場所で保持することで代替可能です。マルチスレッド時に、`counter()->key()`によって実現していたMutexによる排他処理は、`KVS_ENABLE_THREAD_SAFE`をコンパイル時にセットすることで自動で行われるようになりました。

=== kvs::!AnyValueArray ===
以前の`AnyValueArray`の使い方は危険なものが多かったので、直接配列の中身を操作するような関数を廃止し、`ValueArray`をラップすることに集中し、配列の操作は`ValueArray`に任せる形にしました。直接配列の中身を操作したい場合は、`asValueArray`で`ValueArray`型に変換してから使ってください。なお、`v = a.asValueArray<T>()`のようにして生成した`ValueArray v`は、`a`と配列を共有します。このため、`v`を書き換えると、`a`の内容も書き換わります。このことに注意して使ってください。

==== 修正点1 ====
コンストラクタ`AnyValueArray( const T*, size_t )`が廃止されました。以下のように修正してください。

{{{
// 修正前
AnyValueArray a( p, n );
}}}

{{{
// 修正後
AnyValueArray a( kvs::ValueArray( p, n ) );
}}}

==== 修正点2 ====
コンストラクタ`AnyValueArray( const std::vector<T>& )`が廃止されました。以下のように修正してください。

{{{
// 修正前
kvs::AnyValueArray a( v );
}}}

{{{
// 修正後
kvs::AnyValueArray a( kvs::ValueArray( v ) );
}}}

==== 修正点3 ====
`shallowCopy( const ValueArray<T>& )`が廃止されました。以下のように修正してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = kvs::AnyValueArray( b );
}}}

==== 修正点4 ====
`shallowCopy( const AnyValueArray& )`が廃止されました。代わりに代入演算子を使用してください。

{{{
// 修正前
a.shallowCopy( b );
}}}

{{{
// 修正後
a = b;
}}}

==== 修正点5 ====
`deepCopy( const T*, size_t )`が廃止されました。以下のように修正してください。

{{{
// 修正前
a.deepCopy( p, n );
}}}

{{{
// 修正後
a = kvs::AnyValueArray( kvs::ValueArray( p, n ) );
}}}

==== 修正点6 ====
`isEmpty()`の名称が`empty()`に変更されました。

{{{
// 修正前
a.isEmpty();
}}}

{{{
// 修正後
a.empty();
}}}

==== 修正点7 ====
`swapByte()`が廃止されました。代わりに`Endian::Swap()`を使用してください。以下のように修正すれば、同等の機能が得られますが、基本的にエンディアン変換は`ValueArray`の段階で行なってください。

{{{
// 修正前
a.swapByte();
}}}

{{{
// 修正後

}}}

==== 修正点8 ====
`deallocate()`の名称が`release()`に変更されました。

{{{
// 修正前
a.deallocate();
}}}

{{{
// 修正後
a.release();
}}}

==== 修正点9 ====
`pointer()`の名称が`data()`に変更されました。

{{{
// 修正前
a.pointer();
}}}

{{{
// 修正後
a.data();
}}}

==== 修正点10 ====
`pointer<T>()`が廃止されました。以下のようにすれば、同等の機能が得られますが、基本的に`ValueArray`に変換してから`ValueArray.data()`を使うようにしてください。

{{{
// 修正前
a.pointer<T>();
}}}

{{{
// 修正後
static_cast<T*>( a.data() ); //非const版
static_cast<const T*>( a.data() ); //const版
}}}

==== 修正点11 ====
`counter()`が廃止されました。代替の関数はありませんが、`sharedPointer()`を使うことで、同等の機能を得ることができます。詳しくは`ValueArray.counter()`の修正を参照してください。